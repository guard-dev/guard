package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.54

import (
	"context"
	"database/sql"
	"fmt"
	"guarddev/auth"
	"guarddev/awsmiddleware"
	"guarddev/database/postgres"
	"guarddev/graph/model"
	"os"
	"strings"

	"github.com/google/uuid"
	stripe "github.com/stripe/stripe-go/v81"
	"github.com/stripe/stripe-go/v81/billing/meterevent"
	portalsession "github.com/stripe/stripe-go/v81/billingportal/session"
	"github.com/stripe/stripe-go/v81/checkout/session"
	"github.com/stripe/stripe-go/v81/price"
	"go.opentelemetry.io/otel"
	"go.uber.org/zap"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

// ExternalID is the resolver for the externalId field.
func (r *accountConnectionResolver) ExternalID(ctx context.Context, obj *postgres.AccountConnection) (string, error) {
	tracer := otel.Tracer("graph/ExternalID")
	ctx, span := tracer.Start(ctx, "ExternalID")
	defer span.End()

	return obj.ExternalID.String(), nil
}

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, teamSlug string, input model.NewProject) (postgres.Project, error) {
	tracer := otel.Tracer("graph/CreateProject")
	ctx, span := tracer.Start(ctx, "CreateProject")
	defer span.End()

	team, err := r.Database.GetTeamByTeamSlug(ctx, teamSlug)
	if err != nil {
		span.RecordError(err)
		return postgres.Project{}, err
	}

	projectName := input.ProjectName
	projectName = cases.Title(language.Georgian).String(strings.ToLower(projectName))
	projectName = strings.ToLower(strings.Split(projectName, " ")[0])

	var projectSlug string
	var error error = nil
	retries := 5

	for error == nil && retries > 0 {
		retries -= 1
		shortUuid := uuid.NewString()[:8]
		projectSlug = fmt.Sprintf("%s-%s", projectName, shortUuid)
		_, error = r.Database.GetProjectByTeamIdAndProjectSlug(ctx, postgres.GetProjectByTeamIdAndProjectSlugParams{
			TeamID:      team.TeamID,
			ProjectSlug: projectSlug,
		})
	}

	if retries <= 0 {
		projectSlug = uuid.NewString()
	}

	project, err := r.Database.CreateNewProject(ctx, postgres.CreateNewProjectParams{
		TeamID:      team.TeamID,
		ProjectSlug: projectSlug,
		ProjectName: input.ProjectName,
	})
	if err != nil {
		span.RecordError(err)
	}
	return project, err
}

// VerifyAccountID is the resolver for the verifyAccountId field.
func (r *mutationResolver) VerifyAccountID(ctx context.Context, accountID string) (bool, error) {
	tracer := otel.Tracer("graph/VerifyAccountID")
	ctx, span := tracer.Start(ctx, "VerifyAccountID")
	defer span.End()

	email, err := auth.EmailFromContext(ctx)
	if err != nil {
		r.Logger.Logger(ctx).Error("[graph/VerifyAccountID] Could not fetch user email", zap.Error(err))
		span.RecordError(err)
		return false, fmt.Errorf("could not verify account")
	}

	// Get external ID from database
	externalId, err := r.Database.GetExternalIdByEmail(ctx, email)
	if err != nil {
		r.Logger.Logger(ctx).Error("[graph/VerifyAccountID] Could not fetch external ID from the DB", zap.String("userEmail", email))
		span.RecordError(err)
		return false, fmt.Errorf("could not verify account")
	}

	_, err = r.AWSMiddleware.AssumeRole(ctx, awsmiddleware.AssumeRoleProps{
		AWSAccountID: accountID,
		ExternalID:   externalId.String(),
	})
	if err != nil {
		r.Logger.Logger(ctx).Error("[graph/VerifyAccountID] Could not assume AWS role", zap.String("userEmail", email), zap.Error(err), zap.String("accountID", accountID))
		span.RecordError(err)
		return false, fmt.Errorf("could not verify account")
	}

	// Create a new team
	teamSlug := uuid.New().String()
	team, err := r.Database.CreateNewTeam(ctx, postgres.CreateNewTeamParams{
		TeamSlug: teamSlug,
		TeamName: teamSlug,
	})
	if err != nil {
		r.Logger.Logger(ctx).Error("[graph/VerifyAccountID] Failed to create new team", zap.String("userEmail", email), zap.Error(err))
		span.RecordError(err)
		return false, fmt.Errorf("could not verify account")
	}

	// Fetch the user
	user, err := r.Database.GetUserByEmail(ctx, email)
	if err != nil {
		r.Logger.Logger(ctx).Error("[graph/VerifyAccountID] Failed to fetch user", zap.String("userEmail", email), zap.Error(err))
		span.RecordError(err)
		return false, fmt.Errorf("could not verify account")
	}

	// Add team membership for the user
	_, err = r.Database.AddTeamMembership(ctx, postgres.AddTeamMembershipParams{
		TeamID:         team.TeamID,
		MembershipType: postgres.MembershipTypeOWNER,
		UserID:         user.UserID,
	})
	if err != nil {
		r.Logger.Logger(ctx).Error("[graph/VerifyAccountID] Failed to add user to team", zap.String("userEmail", email), zap.Error(err))
		span.RecordError(err)
		return false, fmt.Errorf("could not verify account")
	}

	// Create a new project
	projectSlug := uuid.New().String()
	project, err := r.Database.CreateNewProject(ctx, postgres.CreateNewProjectParams{
		TeamID:      team.TeamID,
		ProjectSlug: projectSlug,
		ProjectName: projectSlug,
	})
	if err != nil {
		r.Logger.Logger(ctx).Error("[graph/VerifyAccountID] Failed to create new project", zap.String("userEmail", email), zap.Error(err))
		span.RecordError(err)
		return false, fmt.Errorf("could not verify account")
	}

	_, err = r.Database.CreateAccountConnection(ctx, postgres.CreateAccountConnectionParams{
		ProjectID:  project.ProjectID,
		AccountID:  accountID,
		ExternalID: externalId,
	})
	if err != nil {
		r.Logger.Logger(ctx).Error("[graph/VerifyAccountID] Failed to create cloud account connection", zap.String("userEmail", email), zap.Error(err))
		span.RecordError(err)
		return false, fmt.Errorf("could not verify account")
	}

	return true, nil
}

// StartScan is the resolver for the startScan field.
func (r *mutationResolver) StartScan(ctx context.Context, teamSlug string, projectSlug string, services []string, regions []string) (string, error) {
	tracer := otel.Tracer("graph/StartScan")
	ctx, span := tracer.Start(ctx, "StartScan")
	defer span.End()

	team, _ := r.Database.GetTeamByTeamSlug(ctx, teamSlug)
	pj, _ := r.Database.GetProjectByTeamIdAndProjectSlug(ctx, postgres.GetProjectByTeamIdAndProjectSlugParams{
		TeamID:      team.TeamID,
		ProjectSlug: projectSlug,
	})

	connections, _ := r.Database.GetConnectionsByProjectId(ctx, pj.ProjectID)

	r.Logger.Logger(ctx).Info(
		"[graph/StartScan] Starting Scan",
		zap.String("teamSlug", teamSlug),
		zap.String("projectSlug", projectSlug),
		zap.Strings("regions", regions),
		zap.Strings("services", services),
		zap.Any("connections", connections))

	// assume role
	res, _ := r.AWSMiddleware.AssumeRole(ctx, awsmiddleware.AssumeRoleProps{
		AWSAccountID: connections[0].AccountID,
		ExternalID:   connections[0].ExternalID.String(),
	})
	// start scan

	// create new scan id
	newScan, _ := r.Database.CreateNewScan(ctx, postgres.CreateNewScanParams{
		ProjectID:    pj.ProjectID,
		RegionCount:  int32(len(regions)),
		ServiceCount: int32(len(services)),
		Services:     services,
		Regions:      regions,
	})

	// start goroutine to process all the scans
	go func(newCtx context.Context) {
		for _, reg := range regions {
			for _, ser := range services {

				scanRes, err := r.AWSMiddleware.StartScan(newCtx, res.AccessKeyID, res.SecretAccessKey, res.SessionToken, []string{reg}, []string{ser})
				if err != nil {
					r.Logger.Logger(newCtx).Error(
						"[graph/StartScan] Could not scan service",
						zap.Error(err),
						zap.String("teamSlug", teamSlug),
						zap.String("projectSlug", projectSlug),
						zap.String("region", reg),
						zap.String("service", ser),
						zap.Any("connections", connections),
					)
					continue
				}

				findings := scanRes[0].ScanItem.Findings

				// summarize with gemini
				summ, err := r.Gemini.SummarizeFindings(newCtx, ser, reg, findings)
				if err != nil {
					r.Logger.Logger(newCtx).Error(
						"[graph/StartScan] Could not summarize findings",
						zap.Error(err),
						zap.Strings("findings", findings),
						zap.String("teamSlug", teamSlug),
						zap.String("projectSlug", projectSlug),
						zap.String("region", reg),
						zap.String("service", ser),
						zap.Any("connections", connections),
					)
					continue
				}

				// insert scan item into DB
				scanItem, err := r.Database.CreateNewScanItem(newCtx, postgres.CreateNewScanItemParams{
					ScanID:   newScan.ScanID,
					Service:  ser,
					Region:   reg,
					Findings: findings,
					Summary:  summ.Summary,
					Remedy:   summ.Remedies,
				})

				var resourceCost int32 = 0
				// insert scan items into DB
				for _, entry := range scanRes[0].ScanItemEntries {
					scanItemEntry, _ := r.Database.CreateNewScanItemEntry(newCtx, postgres.CreateNewScanItemEntryParams{
						ScanItemID: scanItem.ScanItemID,
						Findings:   entry.Findings,
						Title:      entry.Title,
						Summary:    entry.Summary,
						Remedy:     entry.Remedy,
						Commands:   entry.Commands,
					})
					resourceCost += scanItemEntry.ResourceCost
				}

				if err != nil {
					r.Logger.Logger(newCtx).Error(
						"[graph/StartScan] Could not add finding to DB",
						zap.Error(err),
						zap.Strings("findings", findings),
						zap.String("teamSlug", teamSlug),
						zap.String("projectSlug", projectSlug),
						zap.String("region", reg),
						zap.String("service", ser),
						zap.Any("connections", connections),
					)
				}

				r.Database.IncrementScanItemResourceCostByScanItemid(newCtx, postgres.IncrementScanItemResourceCostByScanItemidParams{
					ResourceCost: resourceCost,
					ScanItemID:   scanItem.ScanItemID,
				})
				r.Database.IncrementScanResourceCostByScanId(newCtx, postgres.IncrementScanResourceCostByScanIdParams{
					ResourceCost: resourceCost,
					ScanID:       newScan.ScanID,
				})
				r.Database.IncrementSubscriptionResourcesUsedByTeamId(newCtx, postgres.IncrementSubscriptionResourcesUsedByTeamIdParams{
					ResourcesUsed: resourceCost,
					TeamID:        pj.TeamID,
				})

				// track with meter
				if team.StripeCustomerID.Valid {
					customerId := team.StripeCustomerID.String
					params := &stripe.BillingMeterEventParams{
						EventName: stripe.String("guard_resource_usage_meter"),
						Payload: map[string]string{
							"value":              fmt.Sprintf("%d", resourceCost),
							"stripe_customer_id": customerId,
						},
					}
					_, err := meterevent.New(params)
					if err != nil {
						r.Logger.Logger(newCtx).Error(
							"[graph/StartScan] Failed to track meter event",
							zap.Error(err),
							zap.String("customerId", customerId),
							zap.Int32("resourceCost", resourceCost),
						)
					}
				}
			}
		}
		// mark scan complete
		r.Database.UpdateScanCompletedStatus(newCtx, postgres.UpdateScanCompletedStatusParams{
			ScanCompleted: true,
			ScanID:        newScan.ScanID,
		})
	}(context.Background())

	return newScan.ScanID.String(), nil
}

// CreateCheckoutSession is the resolver for the createCheckoutSession field.
func (r *mutationResolver) CreateCheckoutSession(ctx context.Context, teamSlug string, lookUpKey string) (model.CheckoutSessionResponse, error) {
	tracer := otel.Tracer("graph/CreateCheckoutSession")
	ctx, span := tracer.Start(ctx, "CreateCheckoutSession")
	defer span.End()

	production := os.Getenv("PRODUCTION") != ""

	baseUrl := "https://www.guard.dev"
	if !production {
		baseUrl = "http://localhost:3000"
	}

	SuccessURL := fmt.Sprintf("%s/console", baseUrl)
	CancelURL := fmt.Sprintf("%s/console", baseUrl)

	priceLookUpParams := &stripe.PriceListParams{
		LookupKeys: stripe.StringSlice([]string{lookUpKey}),
	}

	itemIterable := price.List(priceLookUpParams)

	var price *stripe.Price
	for itemIterable.Next() {
		p := itemIterable.Price()
		price = p
	}

	if price == nil {
		return model.CheckoutSessionResponse{}, fmt.Errorf("No item found")
	}

	var stripeLineItems []*stripe.CheckoutSessionLineItemParams
	stripeLineItems = append(stripeLineItems, &stripe.CheckoutSessionLineItemParams{
		Price:    stripe.String(price.ID),
		Quantity: stripe.Int64(1),
	})

	currentCustomer, err := r.Payments.GetCustomerByTeamSlug(ctx, teamSlug)

	params := &stripe.CheckoutSessionParams{
		Mode:               stripe.String(string(stripe.CheckoutSessionModeSubscription)),
		PaymentMethodTypes: stripe.StringSlice([]string{"card"}),
		LineItems:          stripeLineItems,
		SuccessURL:         stripe.String(SuccessURL),
		CancelURL:          stripe.String(CancelURL),
		Customer:           stripe.String(currentCustomer.ID),
	}

	session, err := session.New(params)
	if err != nil {
		return model.CheckoutSessionResponse{}, err
	}

	return model.CheckoutSessionResponse{SessionID: session.ID}, nil
}

// CreatePortalSession is the resolver for the createPortalSession field.
func (r *mutationResolver) CreatePortalSession(ctx context.Context, teamSlug string) (model.PortalSessionResponse, error) {
	tracer := otel.Tracer("graph/CreatePortalSession")
	ctx, span := tracer.Start(ctx, "CreatePortalSession")
	defer span.End()
	production := os.Getenv("PRODUCTION") != ""

	baseUrl := "https://www.guard.dev"
	if !production {
		baseUrl = "http://localhost:3000"
	}

	currentTeam, err := r.Database.GetTeamByTeamSlug(ctx, teamSlug)
	if err != nil || !currentTeam.StripeCustomerID.Valid {
		return model.PortalSessionResponse{}, fmt.Errorf("No customer records found")
	}

	ReturnURL := fmt.Sprintf("%s/console", baseUrl)
	customerId := currentTeam.StripeCustomerID.String
	params := &stripe.BillingPortalSessionParams{
		Customer:  stripe.String(customerId),
		ReturnURL: stripe.String(ReturnURL),
	}

	ps, err := portalsession.New(params)
	if err != nil {
		return model.PortalSessionResponse{}, err
	}
	return model.PortalSessionResponse{SessionURL: ps.URL}, nil
}

// AccountConnections is the resolver for the accountConnections field.
func (r *projectResolver) AccountConnections(ctx context.Context, obj *postgres.Project) ([]postgres.AccountConnection, error) {
	tracer := otel.Tracer("graph/AccountConnections")
	ctx, span := tracer.Start(ctx, "AccountConnections")
	defer span.End()

	connections, err := r.Database.GetConnectionsByProjectId(ctx, obj.ProjectID)
	if err != nil {
		span.RecordError(err)
	}
	return connections, err
}

// Scans is the resolver for the scans field.
func (r *projectResolver) Scans(ctx context.Context, obj *postgres.Project, scanID *string) ([]postgres.Scan, error) {
	tracer := otel.Tracer("graph/Scans")
	ctx, span := tracer.Start(ctx, "Scans")
	defer span.End()

	if scanID == nil {
		return r.Database.GetScansByProjectId(ctx, obj.ProjectID)
	}

	scanUuid, err := uuid.Parse(*scanID)
	if err != nil {
		r.Logger.Logger(ctx).Error(
			"[graph/Scans] Could not resolve scan ID",
			zap.Error(err),
			zap.String("scan_id", *scanID),
		)
		return nil, fmt.Errorf("could not fetch scan")
	}

	scan, _ := r.Database.GetScanByScanIdProjectId(ctx, postgres.GetScanByScanIdProjectIdParams{
		ProjectID: obj.ProjectID,
		ScanID:    scanUuid,
	})

	return []postgres.Scan{scan}, nil
}

// Teams is the resolver for the teams field.
func (r *queryResolver) Teams(ctx context.Context, teamSlug *string) ([]postgres.Team, error) {
	tracer := otel.Tracer("graph/Teams")
	ctx, span := tracer.Start(ctx, "Teams")
	defer span.End()

	email, _ := auth.EmailFromContext(ctx)
	user, _ := r.Database.GetUserByEmail(ctx, email)

	if teamSlug != nil {
		team, err := r.Database.GetTeamByTeamSlug(ctx, *teamSlug)
		return []postgres.Team{team}, err
	}

	return r.Database.GetTeamsByUserId(ctx, user.UserID)
}

// GetExternalID is the resolver for the getExternalId field.
func (r *queryResolver) GetExternalID(ctx context.Context) (string, error) {
	tracer := otel.Tracer("graph/GetExternalID")
	ctx, span := tracer.Start(ctx, "GetExternalID")
	defer span.End()

	email, err := auth.EmailFromContext(ctx)
	if err != nil {
		r.Logger.Logger(ctx).Error("[graph/GetExternalID] Could not fetch user email", zap.Error(err))
		span.RecordError(err)
		return "", fmt.Errorf("could not fetch externalId")
	}

	externalId, err := r.Database.GetExternalIdByEmail(ctx, email)
	if err != nil {
		r.Logger.Logger(ctx).Error("[graph/GetExternalID] Could not fetch external ID from the DB", zap.String("userEmail", email))
		span.RecordError(err)
		return "", fmt.Errorf("could not fetch externalId")
	}

	return externalId.String(), nil
}

// ScanID is the resolver for the scanId field.
func (r *scanResolver) ScanID(ctx context.Context, obj *postgres.Scan) (string, error) {
	tracer := otel.Tracer("graph/ScanID")
	ctx, span := tracer.Start(ctx, "ScanID")
	defer span.End()

	return obj.ScanID.String(), nil
}

// ScanItems is the resolver for the scanItems field.
func (r *scanResolver) ScanItems(ctx context.Context, obj *postgres.Scan) ([]postgres.ScanItem, error) {
	tracer := otel.Tracer("graph/ScanItems")
	ctx, span := tracer.Start(ctx, "ScanItems")
	defer span.End()

	items, err := r.Database.GetScanItemsByScanId(ctx, obj.ScanID)
	if err != nil {
		span.RecordError(err)
	}
	return items, err
}

// Created is the resolver for the created field.
func (r *scanResolver) Created(ctx context.Context, obj *postgres.Scan) (int64, error) {
	tracer := otel.Tracer("graph/Created")
	ctx, span := tracer.Start(ctx, "Created")
	defer span.End()

	return obj.Created.Unix(), nil
}

// ScanItemEntries is the resolver for the scanItemEntries field.
func (r *scanItemResolver) ScanItemEntries(ctx context.Context, obj *postgres.ScanItem) ([]postgres.ScanItemEntry, error) {
	tracer := otel.Tracer("graph/ScanItemEntries")
	ctx, span := tracer.Start(ctx, "ScanItemEntries")
	defer span.End()

	entries, err := r.Database.GetScanItemEntriesByScanId(ctx, obj.ScanItemID)
	if err != nil {
		span.RecordError(err)
		return []postgres.ScanItemEntry{}, nil
	}
	return entries, nil
}

// StripeSubscriptionID is the resolver for the stripeSubscriptionId field.
func (r *subscriptionPlanResolver) StripeSubscriptionID(ctx context.Context, obj *postgres.SubscriptionPlan) (*string, error) {
	tracer := otel.Tracer("graph/StripeSubscriptionID")
	ctx, span := tracer.Start(ctx, "StripeSubscriptionID")
	defer span.End()

	if obj.StripeSubscriptionID.Valid == false {
		return nil, nil
	}
	subscriptionId := obj.StripeSubscriptionID.String
	return &subscriptionId, nil
}

// SubscriptionData is the resolver for the subscriptionData field.
func (r *subscriptionPlanResolver) SubscriptionData(ctx context.Context, obj *postgres.SubscriptionPlan) (*model.SubscriptionData, error) {
	tracer := otel.Tracer("graph/SubscriptionData")
	ctx, span := tracer.Start(ctx, "SubscriptionData")
	defer span.End()

	if obj.StripeSubscriptionID.Valid == false {
		return nil, nil
	}
	subscriptionData, err := r.Payments.GetSubscriptionPlanData(ctx, obj.StripeSubscriptionID.String)
	if err != nil {
		r.Logger.Logger(ctx).Error("Could not fetch subscription plan data %s", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("Could not fetch subscription plan data %s", err.Error())
	}

	subPlan, err := r.Database.GetSubscriptionByStripeSubscriptionId(ctx, sql.NullString{Valid: true, String: obj.StripeSubscriptionID.String})
	if err != nil {
		r.Logger.Logger(ctx).Error("Could not fetch subscription plan data from DB", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("Could not fetch subscription plan data %s", err.Error())
	}

	subscriptionData.ResourcesIncluded = int(subPlan.ResourcesIncluded)
	subscriptionData.ResourcesUsed = int(subPlan.ResourcesUsed)

	return subscriptionData, nil
}

// Projects is the resolver for the projects field.
func (r *teamResolver) Projects(ctx context.Context, obj *postgres.Team, projectSlug *string) ([]postgres.Project, error) {
	tracer := otel.Tracer("graph/Projects")
	ctx, span := tracer.Start(ctx, "Projects")
	defer span.End()

	if projectSlug != nil {
		proj, err := r.Database.GetProjectByTeamIdAndProjectSlug(ctx, postgres.GetProjectByTeamIdAndProjectSlugParams{
			TeamID:      obj.TeamID,
			ProjectSlug: *projectSlug,
		})
		if err != nil {
			span.RecordError(err)
		}
		return []postgres.Project{proj}, err
	}

	projects, err := r.Database.GetProjectsByTeamId(ctx, obj.TeamID)
	if err != nil {
		span.RecordError(err)
	}
	return projects, err
}

// Members is the resolver for the members field.
func (r *teamResolver) Members(ctx context.Context, obj *postgres.Team) ([]postgres.TeamMembership, error) {
	tracer := otel.Tracer("graph/Members")
	ctx, span := tracer.Start(ctx, "Members")
	defer span.End()

	memberships, err := r.Database.GetTeamMembershipsByTeamId(ctx, obj.TeamID)
	if err != nil {
		span.RecordError(err)
	}
	return memberships, err
}

// SubscriptionPlans is the resolver for the subscriptionPlans field.
func (r *teamResolver) SubscriptionPlans(ctx context.Context, obj *postgres.Team, subscriptionID *int64) ([]postgres.SubscriptionPlan, error) {
	tracer := otel.Tracer("graph/SubscriptionPlans")
	ctx, span := tracer.Start(ctx, "SubscriptionPlans")
	defer span.End()

	if subscriptionID == nil {
		sub, err := r.Database.GetSubscriptionByTeamId(ctx, obj.TeamID)
		span.RecordError(err)
		if err != nil {
			return []postgres.SubscriptionPlan{}, nil
		}
		return []postgres.SubscriptionPlan{sub}, nil
	}

	subscription, err := r.Database.GetSubscriptionByTeamIdSubscriptionId(ctx, postgres.GetSubscriptionByTeamIdSubscriptionIdParams{TeamID: obj.TeamID, ID: *subscriptionID})
	if err != nil {
		span.RecordError(err)
	}
	return []postgres.SubscriptionPlan{subscription}, err
}

// MembershipType is the resolver for the membershipType field.
func (r *teamMembershipResolver) MembershipType(ctx context.Context, obj *postgres.TeamMembership) (string, error) {
	tracer := otel.Tracer("graph/MembershipType")
	ctx, span := tracer.Start(ctx, "MembershipType")
	defer span.End()

	return string(obj.MembershipType), nil
}

// User is the resolver for the user field.
func (r *teamMembershipResolver) User(ctx context.Context, obj *postgres.TeamMembership) (model.Userinfo, error) {
	tracer := otel.Tracer("graph/User")
	ctx, span := tracer.Start(ctx, "User")
	defer span.End()

	u, err := r.Database.GetUserById(ctx, obj.UserID)
	if err != nil {
		span.RecordError(err)
		return model.Userinfo{}, err
	}
	uInfo := model.Userinfo{
		UserID:   obj.UserID,
		FullName: u.FullName,
		Email:    u.Email,
	}
	return uInfo, nil
}

// TeamSlug is the resolver for the teamSlug field.
func (r *teamMembershipResolver) TeamSlug(ctx context.Context, obj *postgres.TeamMembership) (string, error) {
	tracer := otel.Tracer("graph/TeamSlug")
	ctx, span := tracer.Start(ctx, "TeamSlug")
	defer span.End()

	teamId := obj.TeamID
	team, err := r.Database.GetTeamByTeamId(ctx, teamId)
	if err != nil {
		span.RecordError(err)
		return "", err
	}
	return team.TeamSlug, nil
}

// TeamName is the resolver for the teamName field.
func (r *teamMembershipResolver) TeamName(ctx context.Context, obj *postgres.TeamMembership) (string, error) {
	tracer := otel.Tracer("graph/TeamName")
	ctx, span := tracer.Start(ctx, "TeamName")
	defer span.End()

	teamId := obj.TeamID
	team, err := r.Database.GetTeamByTeamId(ctx, teamId)
	if err != nil {
		span.RecordError(err)
		return "", err
	}
	return team.TeamName, nil
}

// AccountConnection returns AccountConnectionResolver implementation.
func (r *Resolver) AccountConnection() AccountConnectionResolver {
	return &accountConnectionResolver{r}
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Project returns ProjectResolver implementation.
func (r *Resolver) Project() ProjectResolver { return &projectResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Scan returns ScanResolver implementation.
func (r *Resolver) Scan() ScanResolver { return &scanResolver{r} }

// ScanItem returns ScanItemResolver implementation.
func (r *Resolver) ScanItem() ScanItemResolver { return &scanItemResolver{r} }

// SubscriptionPlan returns SubscriptionPlanResolver implementation.
func (r *Resolver) SubscriptionPlan() SubscriptionPlanResolver { return &subscriptionPlanResolver{r} }

// Team returns TeamResolver implementation.
func (r *Resolver) Team() TeamResolver { return &teamResolver{r} }

// TeamMembership returns TeamMembershipResolver implementation.
func (r *Resolver) TeamMembership() TeamMembershipResolver { return &teamMembershipResolver{r} }

type accountConnectionResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type projectResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type scanResolver struct{ *Resolver }
type scanItemResolver struct{ *Resolver }
type subscriptionPlanResolver struct{ *Resolver }
type teamResolver struct{ *Resolver }
type teamMembershipResolver struct{ *Resolver }
